<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="A Valentine's Day scavenger hunt game for Patty">
  <title>Valentine's Day Game for Patty</title>

  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Caveat:wght@400;700&family=Pacifico&display=swap" rel="stylesheet">

  <style>
    :root {
      --white: #FFFFFF;
      --red: #FF4458;
      --lavender: #E6D5F5;
      --red-dark: #D63447;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Caveat', cursive;
      background: linear-gradient(135deg, var(--white) 0%, var(--lavender) 100%);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .screen {
      display: none;
      width: 100%;
      max-width: 900px;
      margin: 0 auto;
    }

    .screen.active {
      display: block;
    }

    /* Landing Screen */
    #landing {
      text-align: center;
    }

    #landing h1 {
      font-family: 'Pacifico', cursive;
      color: var(--red);
      font-size: clamp(2rem, 5vw, 3.5rem);
      margin-bottom: 40px;
      line-height: 1.3;
    }

    #landing-svg {
      max-width: 400px;
      width: 100%;
      height: auto;
      margin: 0 auto 30px;
    }

    #landing p {
      font-size: clamp(1.5rem, 3vw, 2rem);
      margin-bottom: 30px;
      color: #333;
    }

    .btn {
      font-family: 'Caveat', cursive;
      font-size: clamp(1.5rem, 3vw, 2rem);
      font-weight: 700;
      background: var(--red);
      color: var(--white);
      border: none;
      padding: 15px 50px;
      border-radius: 50px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(255, 68, 88, 0.3);
    }

    .btn:hover {
      background: var(--red-dark);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(255, 68, 88, 0.4);
    }

    .btn:active {
      transform: translateY(0);
    }

    /* Puzzle Screen */
    #puzzle {
      padding-bottom: 100px;
    }

    .puzzle-card {
      background: var(--white);
      border: 3px solid var(--lavender);
      border-radius: 20px;
      padding: 40px;
      margin: 0 auto;
      max-width: 700px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
    }

    .riddle-text {
      font-size: clamp(1.5rem, 3vw, 2.2rem);
      text-align: center;
      margin-bottom: 30px;
      color: #333;
      line-height: 1.5;
    }

    .input-group {
      text-align: center;
    }

    #answer-input {
      font-family: 'Caveat', cursive;
      font-size: clamp(1.3rem, 2.5vw, 1.8rem);
      padding: 15px 20px;
      border: 2px solid var(--lavender);
      border-radius: 10px;
      width: 100%;
      max-width: 400px;
      margin-bottom: 20px;
      text-align: center;
      transition: border-color 0.3s ease;
    }

    #answer-input:focus {
      outline: none;
      border-color: var(--red);
    }

    .error-message {
      color: var(--red);
      font-size: clamp(1.2rem, 2vw, 1.5rem);
      margin-bottom: 15px;
      min-height: 30px;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .error-message.show {
      opacity: 1;
      animation: shake 0.5s ease;
    }

    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-10px); }
      75% { transform: translateX(10px); }
    }

    /* Accumulated Answers Bar */
    .answers-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: var(--white);
      border-top: 3px solid var(--lavender);
      padding: 15px 20px;
      display: flex;
      gap: 10px;
      overflow-x: auto;
      scroll-snap-type: x mandatory;
      box-shadow: 0 -4px 15px rgba(0, 0, 0, 0.1);
    }

    .answers-bar::-webkit-scrollbar {
      height: 8px;
    }

    .answers-bar::-webkit-scrollbar-track {
      background: var(--lavender);
    }

    .answers-bar::-webkit-scrollbar-thumb {
      background: var(--red);
      border-radius: 4px;
    }

    .answer-badge {
      background: var(--red);
      color: var(--white);
      padding: 8px 20px;
      border-radius: 20px;
      font-size: clamp(1rem, 2vw, 1.3rem);
      font-weight: 700;
      white-space: nowrap;
      scroll-snap-align: start;
      flex-shrink: 0;
    }

    /* Unscramble Screen */
    #unscramble {
      padding: 40px 20px;
      max-width: 1000px;
      margin: 0 auto;
    }

    .unscramble-instructions {
      font-size: clamp(1.8rem, 3vw, 2.5rem);
      text-align: center;
      margin-bottom: 40px;
      color: #333;
      opacity: 0;
      animation: fadeIn 0.8s ease forwards;
    }

    @keyframes fadeIn {
      to { opacity: 1; }
    }

    .word-bubbles-pool {
      display: flex;
      flex-wrap: nowrap;
      justify-content: center;
      gap: 15px;
      min-height: 150px;
      margin-bottom: 50px;
      padding: 20px;
    }

    /* Only wrap on smaller screens */
    @media (max-width: 900px) {
      .word-bubbles-pool {
        flex-wrap: wrap;
      }
    }

    .word-bubble {
      background: var(--red);
      color: var(--white);
      padding: 0.4em 1.2em;
      border-radius: 25px;
      font-size: clamp(1.2rem, 2.5vw, 1.8rem);
      font-weight: 700;
      cursor: grab;
      transition: all 0.3s ease;
      box-shadow: 0 4px 10px rgba(255, 68, 88, 0.3);
      user-select: none;
      position: relative;
      line-height: 1.2;
      height: fit-content;
      max-height: 50px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .word-bubble:active {
      cursor: grabbing;
    }

    .word-bubble.dragging {
      transform: scale(1.2);
      opacity: 0.8;
      z-index: 1000;
    }

    .word-bubble.locked {
      cursor: not-allowed;
      opacity: 0.6;
    }

    .word-bubble.correct {
      color: #00FF00;
    }

    .blanks-container {
      display: flex;
      flex-wrap: nowrap;
      justify-content: center;
      gap: 10px;
      margin-bottom: 30px;
      padding: 20px;
    }

    /* Only wrap on smaller screens */
    @media (max-width: 900px) {
      .blanks-container {
        flex-wrap: wrap;
      }
    }

    .blank {
      min-width: 80px;
      height: 50px;
      border: 3px dashed var(--lavender);
      border-radius: 15px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
      position: relative;
    }

    .blank.filled {
      border-style: solid;
      border-color: var(--red);
    }

    .blank.drag-over {
      background: rgba(255, 68, 88, 0.1);
      transform: scale(1.05);
    }

    /* Final Question Screen */
    .final-question-container {
      text-align: center;
      max-width: 700px;
      margin: 0 auto;
      padding-top: 60px;
      display: none;
    }

    .final-question-text {
      font-family: 'Pacifico', cursive;
      font-size: clamp(2rem, 4vw, 3rem);
      color: var(--red);
      margin-bottom: 60px;
      min-height: 80px;
    }

    .final-instruction {
      font-size: clamp(1.5rem, 3vw, 2rem);
      color: #333;
      margin-bottom: 30px;
      display: none;
    }

    #final-answer-input {
      font-family: 'Caveat', cursive;
      font-size: clamp(1.3rem, 2.5vw, 1.8rem);
      padding: 15px 20px;
      border: 2px solid var(--lavender);
      border-radius: 10px;
      width: 100%;
      max-width: 400px;
      margin-bottom: 20px;
      text-align: center;
      transition: border-color 0.3s ease;
    }

    #final-answer-input:focus {
      outline: none;
      border-color: var(--red);
    }

    #final-error-message {
      color: var(--red);
      font-size: clamp(1.2rem, 2vw, 1.5rem);
      margin-bottom: 15px;
      min-height: 30px;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    #final-error-message.show {
      opacity: 1;
      animation: shake 0.5s ease;
    }

    /* Victory Screen */
    #victory {
      position: relative;
      width: 100%;
      height: 100vh;
      overflow: hidden;
    }

    #fireworks-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    #victory-content {
      position: relative;
      z-index: 2;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      opacity: 0;
      animation: fadeInContent 1.5s ease forwards;
    }

    @keyframes fadeInContent {
      to { opacity: 1; }
    }

    #victory-svg {
      width: 100%;
      max-width: 400px;
      height: auto;
      margin: 0 auto;
      filter: drop-shadow(0 4px 20px rgba(0, 0, 0, 0.1));
    }

    #victory-signature {
      font-family: 'Pacifico', cursive;
      font-size: clamp(2rem, 4vw, 3rem);
      color: var(--red);
      margin-top: 40px;
      text-align: center;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
    }

    /* Victory Animations - keeping old ones for compatibility but won't be used */
    @keyframes cuddle {
      0% { transform: translateX(0); }
      100% { transform: translateX(-5px); }
    }

    @keyframes sleep {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(-8deg); }
    }

    @keyframes angry-shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-3px); }
      50% { transform: translateX(3px); }
      75% { transform: translateX(-3px); }
    }

    @keyframes anger-pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.3); }
    }

    @keyframes heart-grow {
      0% {
        opacity: 0;
        transform: scale(0);
      }
      100% {
        opacity: 1;
        transform: scale(1);
      }
    }

    .stage-cuddle #woman {
      animation: cuddle 5s ease-in-out forwards;
    }

    .stage-sleep #man-head {
      animation: sleep 3s ease-out forwards;
      transform-origin: 265px 125px;
    }

    .stage-angry #woman {
      animation: angry-shake 0.3s ease-in-out infinite;
    }

    .stage-angry #anger-mark {
      animation: anger-pulse 0.6s ease-in-out infinite;
    }

    .stage-heart #heart,
    .stage-heart #signature {
      animation: heart-grow 1s ease-out forwards;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .word-bubbles-pool {
        min-height: 120px;
      }

      .blanks-container {
        gap: 8px;
      }

      .blank {
        min-width: 60px;
        height: 45px;
      }
    }
  </style>
</head>
<body>
  <!-- Landing Screen -->
  <div id="landing" class="screen active">
    <h1>A Valentine's Day game for Patty</h1>
    
    <svg id="landing-svg" viewBox="0 0 400 300" xmlns="http://www.w3.org/2000/svg">
      <!-- Floating hearts -->
      <circle cx="100" cy="80" r="15" fill="#FFB6C1" opacity="0.6"/>
      <circle cx="105" cy="75" r="15" fill="#FFB6C1" opacity="0.6"/>
      <path d="M 102.5 95 L 102.5 70" fill="#FFB6C1" opacity="0.6"/>

      <circle cx="300" cy="100" r="15" fill="#FFB6C1" opacity="0.6"/>
      <circle cx="305" cy="95" r="15" fill="#FFB6C1" opacity="0.6"/>
      <path d="M 302.5 115 L 302.5 90" fill="#FFB6C1" opacity="0.6"/>

      <circle cx="320" cy="180" r="12" fill="#FFB6C1" opacity="0.6"/>
      <circle cx="325" cy="176" r="12" fill="#FFB6C1" opacity="0.6"/>
      <path d="M 322.5 195 L 322.5 173" fill="#FFB6C1" opacity="0.6"/>

      <!-- Woman (left) -->
      <g id="woman-landing">
        <!-- Long hair strands - covering top of head, visible individual strands, tapering at bottom -->
        <!-- Left side hair -->
        <path d="M 176 95 Q 166 100 164 110 L 164 145 Q 163 165 161 180" stroke="#000" stroke-width="2" fill="none" stroke-linecap="round"/>
        <path d="M 178 94 Q 168 99 166 109 L 166 145 Q 165 165 163 180" stroke="#000" stroke-width="2" fill="none" stroke-linecap="round"/>
        <path d="M 180 93 Q 170 98 168 108 L 168 145 Q 167 165 165 180" stroke="#000" stroke-width="2" fill="none" stroke-linecap="round"/>
        <path d="M 182 92 Q 172 97 170 107 L 170 145 Q 169 165 167 180" stroke="#000" stroke-width="2" fill="none" stroke-linecap="round"/>
        <path d="M 184 91 Q 174 96 172 106 L 172 145 Q 171 165 169 180" stroke="#000" stroke-width="2" fill="none" stroke-linecap="round"/>
        
        <!-- Top coverage hair strands -->
        <path d="M 186 90 Q 180 88 176 92" stroke="#000" stroke-width="2" fill="none" stroke-linecap="round"/>
        <path d="M 186 90 Q 192 88 196 92" stroke="#000" stroke-width="2" fill="none" stroke-linecap="round"/>
        <path d="M 183 89 Q 186 87 189 89" stroke="#000" stroke-width="2" fill="none" stroke-linecap="round"/>
        
        <!-- Right side hair -->
        <path d="M 188 91 Q 198 96 200 106 L 200 145 Q 201 165 203 180" stroke="#000" stroke-width="2" fill="none" stroke-linecap="round"/>
        <path d="M 190 92 Q 200 97 202 107 L 202 145 Q 203 165 205 180" stroke="#000" stroke-width="2" fill="none" stroke-linecap="round"/>
        <path d="M 192 93 Q 202 98 204 108 L 204 145 Q 205 165 207 180" stroke="#000" stroke-width="2" fill="none" stroke-linecap="round"/>
        <path d="M 194 94 Q 204 99 206 109 L 206 145 Q 207 165 209 180" stroke="#000" stroke-width="2" fill="none" stroke-linecap="round"/>
        <path d="M 196 95 Q 206 100 208 110 L 208 145 Q 209 165 211 180" stroke="#000" stroke-width="2" fill="none" stroke-linecap="round"/>
        
        <!-- Head -->
        <circle cx="186" cy="110" r="20" fill="none" stroke="#000" stroke-width="3"/>
        <!-- Eyes -->
        <circle cx="180" cy="107" r="3" fill="#000"/>
        <circle cx="192" cy="107" r="3" fill="#000"/>
        <!-- Smile -->
        <path d="M 178 116 Q 186 122 194 116" stroke="#000" stroke-width="2" fill="none" stroke-linecap="round"/>
        <!-- Body -->
        <line x1="186" y1="130" x2="186" y2="180" stroke="#000" stroke-width="3" stroke-linecap="round"/>
        <line x1="186" y1="150" x2="166" y2="165" stroke="#000" stroke-width="3" stroke-linecap="round"/>
        <line x1="186" y1="150" x2="206" y2="165" stroke="#000" stroke-width="3" stroke-linecap="round"/>
        <line x1="186" y1="180" x2="170" y2="210" stroke="#000" stroke-width="3" stroke-linecap="round"/>
        <line x1="186" y1="180" x2="202" y2="210" stroke="#000" stroke-width="3" stroke-linecap="round"/>
      </g>

      <!-- Heart between them -->
      <circle cx="218" cy="150" r="8" fill="#FF4458"/>
      <circle cx="224" cy="150" r="8" fill="#FF4458"/>
      <path d="M 211 150 L 221 165 L 231 150" fill="#FF4458"/>

      <!-- Man (right) -->
      <g id="man-landing">
        <!-- Flatter, fuller spiky hair covering top better -->
        <!-- Top row - flatter spikes -->
        <line x1="245" y1="95" x2="243" y2="89" stroke="#000" stroke-width="3" stroke-linecap="round"/>
        <line x1="248" y1="94" x2="247" y2="88" stroke="#000" stroke-width="3" stroke-linecap="round"/>
        <line x1="250" y1="93" x2="250" y2="87" stroke="#000" stroke-width="3" stroke-linecap="round"/>
        <line x1="252" y1="94" x2="253" y2="88" stroke="#000" stroke-width="3" stroke-linecap="round"/>
        <line x1="255" y1="95" x2="257" y2="89" stroke="#000" stroke-width="3" stroke-linecap="round"/>
        
        <!-- Fill in top coverage -->
        <line x1="242" y1="97" x2="240" y2="92" stroke="#000" stroke-width="3" stroke-linecap="round"/>
        <line x1="246" y1="96" x2="245" y2="91" stroke="#000" stroke-width="3" stroke-linecap="round"/>
        <line x1="254" y1="96" x2="255" y2="91" stroke="#000" stroke-width="3" stroke-linecap="round"/>
        <line x1="258" y1="97" x2="260" y2="92" stroke="#000" stroke-width="3" stroke-linecap="round"/>
        
        <!-- Side spikes - fuller coverage -->
        <line x1="237" y1="100" x2="234" y2="96" stroke="#000" stroke-width="3" stroke-linecap="round"/>
        <line x1="239" y1="99" x2="236" y2="95" stroke="#000" stroke-width="3" stroke-linecap="round"/>
        <line x1="235" y1="102" x2="232" y2="99" stroke="#000" stroke-width="3" stroke-linecap="round"/>
        <line x1="233" y1="105" x2="230" y2="103" stroke="#000" stroke-width="3" stroke-linecap="round"/>
        
        <line x1="263" y1="100" x2="266" y2="96" stroke="#000" stroke-width="3" stroke-linecap="round"/>
        <line x1="261" y1="99" x2="264" y2="95" stroke="#000" stroke-width="3" stroke-linecap="round"/>
        <line x1="265" y1="102" x2="268" y2="99" stroke="#000" stroke-width="3" stroke-linecap="round"/>
        <line x1="267" y1="105" x2="270" y2="103" stroke="#000" stroke-width="3" stroke-linecap="round"/>
        
        <!-- Head -->
        <circle cx="250" cy="110" r="20" fill="none" stroke="#000" stroke-width="3"/>
        <!-- Eyes -->
        <circle cx="244" cy="107" r="3" fill="#000"/>
        <circle cx="256" cy="107" r="3" fill="#000"/>
        <!-- Smile -->
        <path d="M 242 116 Q 250 122 258 116" stroke="#000" stroke-width="2" fill="none" stroke-linecap="round"/>
        <!-- Body -->
        <line x1="250" y1="130" x2="250" y2="180" stroke="#000" stroke-width="3" stroke-linecap="round"/>
        <line x1="250" y1="150" x2="230" y2="165" stroke="#000" stroke-width="3" stroke-linecap="round"/>
        <line x1="250" y1="150" x2="270" y2="165" stroke="#000" stroke-width="3" stroke-linecap="round"/>
        <line x1="250" y1="180" x2="234" y2="210" stroke="#000" stroke-width="3" stroke-linecap="round"/>
        <line x1="250" y1="180" x2="266" y2="210" stroke="#000" stroke-width="3" stroke-linecap="round"/>
      </g>
    </svg>
    
    <p>Solve the puzzles to win!</p>
    <button id="start-btn" class="btn">Start</button>
  </div>

  <!-- Puzzle Screen -->
  <div id="puzzle" class="screen">
    <div class="puzzle-card">
      <p id="riddle-text" class="riddle-text"></p>
      <div class="input-group">
        <div id="error-message" class="error-message">Not quite! Try again</div>
        <input type="text" id="answer-input" placeholder="Your answer...">
        <br><br>
        <button id="submit-btn" class="btn">Submit</button>
      </div>
    </div>
    <div id="answers-bar" class="answers-bar"></div>
  </div>

  <!-- Unscramble Screen -->
  <div id="unscramble" class="screen">
    <div class="unscramble-instructions">Drag & drop to unscramble!</div>
    <div id="word-bubbles-pool" class="word-bubbles-pool"></div>
    <div id="blanks-container" class="blanks-container"></div>
    
    <div id="final-question-container" class="final-question-container">
      <div class="final-question-text" id="final-question-text"></div>
      <div class="input-group">
        <div id="final-error-message" class="error-message">Not quite! Try again</div>
        <input type="text" id="final-answer-input" placeholder="Your answer...">
        <br><br>
        <button id="final-submit-btn" class="btn">Submit</button>
      </div>
    </div>
  </div>

  <!-- Victory Screen -->
  <div id="victory" class="screen">
    <canvas id="fireworks-canvas"></canvas>
    <div id="victory-content">
      <svg id="victory-svg" viewBox="0 0 300 400" xmlns="http://www.w3.org/2000/svg">
        <!-- Man (Left Figure) -->
        <g id="victory-man">
          <!-- Head -->
          <circle cx="80" cy="100" r="30" fill="#FFE4C4" stroke="#000" stroke-width="2"/>
          
          <!-- Hair -->
          <path d="M 55 95 Q 55 70 80 65 Q 105 70 105 95" fill="#654321" stroke="#000" stroke-width="2"/>
          
          <!-- Eyes -->
          <circle cx="72" cy="98" r="3" fill="#000"/>
          <circle cx="88" cy="98" r="3" fill="#000"/>
          
          <!-- Smile -->
          <path d="M 70 108 Q 80 113 90 108" stroke="#000" stroke-width="2" fill="none" stroke-linecap="round"/>
          
          <!-- Body -->
          <line x1="80" y1="130" x2="80" y2="220" stroke="#000" stroke-width="3"/>
          
          <!-- Arms -->
          <line x1="80" y1="150" x2="50" y2="180" stroke="#000" stroke-width="3"/>
          <line x1="80" y1="150" x2="110" y2="180" stroke="#000" stroke-width="3"/>
          
          <!-- Legs -->
          <line x1="80" y1="220" x2="60" y2="280" stroke="#000" stroke-width="3"/>
          <line x1="80" y1="220" x2="100" y2="280" stroke="#000" stroke-width="3"/>
          
          <!-- Shirt color -->
          <circle cx="80" cy="170" r="15" fill="#4A90E2" opacity="0.6"/>
        </g>

        <!-- Heart (Center) -->
        <g id="victory-heart">
          <path d="M 150 160 
                   C 150 145, 135 130, 120 130
                   C 105 130, 95 140, 95 155
                   C 95 175, 150 210, 150 210
                   C 150 210, 205 175, 205 155
                   C 205 140, 195 130, 180 130
                   C 165 130, 150 145, 150 160 Z" 
                fill="#FF1744" 
                stroke="#C41230" 
                stroke-width="2"/>
        </g>

        <!-- Woman (Right Figure) -->
        <g id="victory-woman">
          <!-- Head -->
          <circle cx="220" cy="100" r="30" fill="#FFE4C4" stroke="#000" stroke-width="2"/>
          
          <!-- Hair (longer, flowing) -->
          <path d="M 195 95 Q 195 65 220 60 Q 245 65 245 95 L 245 110 Q 240 115 220 115 Q 200 115 195 110 Z" 
                fill="#8B4513" stroke="#000" stroke-width="2"/>
          
          <!-- Eyes -->
          <circle cx="212" cy="98" r="3" fill="#000"/>
          <circle cx="228" cy="98" r="3" fill="#000"/>
          
          <!-- Smile -->
          <path d="M 210 108 Q 220 113 230 108" stroke="#000" stroke-width="2" fill="none" stroke-linecap="round"/>
          
          <!-- Body -->
          <line x1="220" y1="130" x2="220" y2="220" stroke="#000" stroke-width="3"/>
          
          <!-- Arms -->
          <line x1="220" y1="150" x2="190" y2="180" stroke="#000" stroke-width="3"/>
          <line x1="220" y1="150" x2="250" y2="180" stroke="#000" stroke-width="3"/>
          
          <!-- Legs -->
          <line x1="220" y1="220" x2="200" y2="280" stroke="#000" stroke-width="3"/>
          <line x1="220" y1="220" x2="240" y2="280" stroke="#000" stroke-width="3"/>
          
          <!-- Dress/shirt color -->
          <circle cx="220" cy="170" r="15" fill="#E91E63" opacity="0.6"/>
        </g>
      </svg>
      <div id="victory-signature">Love, Vince</div>
    </div>
  </div>

  <script>
    // Game state
    const state = {
      currentScreen: 'landing',
      currentPuzzle: 0,
      collectedAnswers: [],
      puzzles: [
        {
          riddle: "I don't play games, I run them. I'm the 5th generation in my family. Find me to start your quest.",
          answer: "Tie"
        },
        {
          riddle: "Susan's been slacking off. She just sits there doing nothing, spinning in her own thoughts.",
          answer: "U"
        },
        {
          riddle: "E orâ€¦",
          answer: "N"
        },
        {
          riddle: "The first step on the stairway to heaven (or the last step on the stairway to hell).",
          answer: "Eye"
        },
        {
          riddle: "A woman in white, she's standing on height. A man below, she seems to know. To say hello, he'll need to climb. But he won't and he can't, 'cause they're frozen in time.",
          answer: "N"
        },
        {
          riddle: "My favorite photo of you.",
          answer: "Bee"
        },
        {
          riddle: "Look through your contacts.",
          answer: "M"
        },
        {
          riddle: "Mirror mirror on a door, inside you'll find what you're looking for.",
          answer: "Will"
        },
        {
          riddle: "Your partner's initials (full legal name)",
          answer: "VAL"
        }
      ],
      correctOrder: ["Will", "U", "Bee", "M", "Eye", "VAL", "N", "Tie", "N"],
      unscrambleState: {
        placed: {},
        locked: new Set()
      }
    };

    // Drag and drop state
    let draggedElement = null;
    let draggedFrom = null;

    // Initialize game
    function initGame() {
      document.getElementById('start-btn').addEventListener('click', startGame);
      document.getElementById('submit-btn').addEventListener('click', submitAnswer);
      document.getElementById('answer-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          submitAnswer();
        }
      });
      document.getElementById('final-submit-btn').addEventListener('click', submitFinalAnswer);
      document.getElementById('final-answer-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          submitFinalAnswer();
        }
      });
    }

    // Show screen
    function showScreen(screenName) {
      document.querySelectorAll('.screen').forEach(screen => {
        screen.classList.remove('active');
      });
      document.getElementById(screenName).classList.add('active');
      state.currentScreen = screenName;
    }

    // Start game
    function startGame() {
      showScreen('puzzle');
      loadPuzzle(0);
    }

    // Load puzzle
    function loadPuzzle(puzzleIndex) {
      const puzzle = state.puzzles[puzzleIndex];
      document.getElementById('riddle-text').textContent = puzzle.riddle;
      document.getElementById('answer-input').value = '';
      document.getElementById('error-message').classList.remove('show');
      displayAccumulatedAnswers();
    }

    // Validate answer
    function validateAnswer(input, correctAnswer) {
      return input.trim().toLowerCase() === correctAnswer.toLowerCase();
    }

    // Submit answer
    function submitAnswer() {
      const input = document.getElementById('answer-input').value;
      const puzzle = state.puzzles[state.currentPuzzle];
      const errorMessage = document.getElementById('error-message');

      // Check for shortcut on question 1
      if (state.currentPuzzle === 0 && input.trim().toLowerCase() === 'krabbypatty') {
        // Skip to unscramble with all answers collected
        state.collectedAnswers = state.puzzles.map(p => p.answer);
        state.currentPuzzle = state.puzzles.length;
        showUnscrambleScreen();
        return;
      }

      if (validateAnswer(input, puzzle.answer)) {
        errorMessage.classList.remove('show');
        advancePuzzle();
      } else {
        errorMessage.classList.add('show');
        setTimeout(() => {
          errorMessage.classList.remove('show');
        }, 2000);
      }
    }

    // Advance to next puzzle
    function advancePuzzle() {
      const currentAnswer = state.puzzles[state.currentPuzzle].answer;
      state.collectedAnswers.push(currentAnswer);
      state.currentPuzzle++;

      if (state.currentPuzzle < state.puzzles.length) {
        loadPuzzle(state.currentPuzzle);
      } else {
        showUnscrambleScreen();
      }
    }

    // Display accumulated answers
    function displayAccumulatedAnswers() {
      const answersBar = document.getElementById('answers-bar');
      answersBar.innerHTML = '';

      state.collectedAnswers.forEach(answer => {
        const badge = document.createElement('div');
        badge.className = 'answer-badge';
        badge.textContent = answer;
        answersBar.appendChild(badge);
      });
    }

    // Show unscramble screen
    function showUnscrambleScreen() {
      showScreen('unscramble');
      
      // Animate badges from bottom bar to pool
      setTimeout(() => {
        const pool = document.getElementById('word-bubbles-pool');
        const blanksContainer = document.getElementById('blanks-container');
        
        // Create word bubbles in scattered positions
        state.collectedAnswers.forEach((answer, index) => {
          const bubble = document.createElement('div');
          bubble.className = 'word-bubble';
          bubble.textContent = answer;
          bubble.draggable = true;
          bubble.dataset.word = answer;
          bubble.dataset.bubbleId = `bubble-${index}`; // Unique ID for each bubble
          bubble.dataset.originalIndex = index;
          
          // Add random positioning
          bubble.style.animation = `fadeIn 0.5s ease ${index * 0.1}s forwards`;
          
          setupDragHandlers(bubble);
          pool.appendChild(bubble);
        });
        
        // Create blanks
        for (let i = 0; i < 9; i++) {
          const blank = document.createElement('div');
          blank.className = 'blank';
          blank.dataset.position = i;
          
          setupDropHandlers(blank);
          blanksContainer.appendChild(blank);
        }
      }, 300);
    }

    // Setup drag handlers for word bubbles
    function setupDragHandlers(bubble) {
      bubble.addEventListener('dragstart', (e) => {
        // Check if this specific bubble is locked, not just the word
        if (bubble.classList.contains('locked')) {
          e.preventDefault();
          return;
        }
        
        draggedElement = bubble;
        draggedFrom = bubble.parentElement.classList.contains('blank') ? bubble.parentElement : 'pool';
        bubble.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
      });

      bubble.addEventListener('dragend', (e) => {
        bubble.classList.remove('dragging');
      });
    }

    // Setup drop handlers for blanks
    function setupDropHandlers(blank) {
      blank.addEventListener('dragover', (e) => {
        e.preventDefault();
        blank.classList.add('drag-over');
      });

      blank.addEventListener('dragleave', (e) => {
        blank.classList.remove('drag-over');
      });

      blank.addEventListener('drop', (e) => {
        e.preventDefault();
        blank.classList.remove('drag-over');
        
        if (!draggedElement) return;
        
        const position = parseInt(blank.dataset.position);
        const word = draggedElement.dataset.word;
        const bubbleId = draggedElement.dataset.bubbleId;
        
        // If blank already has a word, swap or move back to pool
        const existingBubble = blank.querySelector('.word-bubble');
        if (existingBubble && existingBubble !== draggedElement) {
          // Move existing bubble back to pool or where dragged element came from
          if (draggedFrom === 'pool') {
            document.getElementById('word-bubbles-pool').appendChild(existingBubble);
          } else {
            draggedFrom.appendChild(existingBubble);
          }
          // Remove the existing bubble's placement record
          const existingBubbleId = existingBubble.dataset.bubbleId;
          delete state.unscrambleState.placed[blank.dataset.position];
        }
        
        // If dragging from another blank, clear that blank's state
        if (draggedFrom !== 'pool' && draggedFrom !== blank) {
          delete state.unscrambleState.placed[draggedFrom.dataset.position];
          draggedFrom.classList.remove('filled'); // Revert to dashed border
        }
        
        blank.appendChild(draggedElement);
        blank.classList.add('filled');
        state.unscrambleState.placed[position] = bubbleId;
        
        // Check if correct position
        if (state.correctOrder[position] === word) {
          draggedElement.classList.add('correct');
          draggedElement.classList.add('locked'); // Lock this specific bubble
        } else {
          draggedElement.classList.remove('correct');
          draggedElement.classList.remove('locked');
        }
        
        draggedElement = null;
        draggedFrom = null;
        
        checkUnscrambleComplete();
      });
    }

    // Setup drop handler for pool
    const pool = document.getElementById('word-bubbles-pool');
    pool.addEventListener('dragover', (e) => {
      e.preventDefault();
    });

    pool.addEventListener('drop', (e) => {
      e.preventDefault();
      
      if (!draggedElement) return;
      
      // Remove from blank if it was in one
      if (draggedFrom !== 'pool') {
        const bubbleId = draggedElement.dataset.bubbleId;
        delete state.unscrambleState.placed[draggedFrom.dataset.position];
        draggedFrom.classList.remove('filled'); // Revert to dashed border
      }
      
      pool.appendChild(draggedElement);
      draggedElement.classList.remove('correct');
      draggedElement.classList.remove('locked');
      
      draggedElement = null;
      draggedFrom = null;
    });

    // Check if unscramble is complete
    function checkUnscrambleComplete() {
      const blanks = document.querySelectorAll('.blank');
      let allFilled = true;
      let allCorrect = true;
      
      blanks.forEach((blank, index) => {
        const bubble = blank.querySelector('.word-bubble');
        if (!bubble) {
          allFilled = false;
        } else if (state.correctOrder[index] !== bubble.dataset.word) {
          allCorrect = false;
        }
      });
      
      if (allFilled && allCorrect) {
        // Immediately fade out instructions
        const instructions = document.querySelector('.unscramble-instructions');
        instructions.style.animation = 'none'; // Remove the fadeIn animation
        instructions.style.transition = 'opacity 0.5s ease';
        instructions.style.opacity = '0';
        
        // Completely remove from layout after fade
        setTimeout(() => {
          instructions.style.display = 'none';
        }, 500);
        
        setTimeout(() => {
          transformToQuestion();
        }, 500);
      }
    }

    // Transform unscrambled phrase to proper question
    function transformToQuestion() {
      const blanksContainer = document.getElementById('blanks-container');
      const pool = document.getElementById('word-bubbles-pool');
      const instructions = document.querySelector('.unscramble-instructions');
      
      // Collect all bubbles from blanks into a single phrase container
      const blanks = document.querySelectorAll('.blank');
      const phraseContainer = document.createElement('div');
      phraseContainer.style.cssText = `
        display: flex;
        gap: 10px;
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
        transition: all 1s ease;
        margin-bottom: 30px;
      `;
      
      // Move bubbles from blanks to phrase container
      blanks.forEach(blank => {
        const bubble = blank.querySelector('.word-bubble');
        if (bubble) {
          const clonedBubble = bubble.cloneNode(true);
          clonedBubble.draggable = false;
          phraseContainer.appendChild(clonedBubble);
        }
      });
      
      // Clear blanks and add phrase container
      blanksContainer.innerHTML = '';
      blanksContainer.appendChild(phraseContainer);
      
      // Float bubbles up immediately (instructions already faded out)
      setTimeout(() => {
        phraseContainer.style.transform = 'translateY(-200px)';
      }, 300);
      
      // After floating, fade out bubbles and fade in correct text
      setTimeout(() => {
        phraseContainer.style.transition = 'opacity 2s ease';
        phraseContainer.style.opacity = '0';
        
        // Start fading in the correct text while bubbles fade out
        setTimeout(() => {
          // Position the question container at the top where bubbles floated to
          const questionContainer = document.getElementById('final-question-container');
          const questionText = document.getElementById('final-question-text');
          const inputGroup = questionContainer.querySelector('.input-group');
          
          // Hide input group initially
          inputGroup.style.opacity = '0';
          inputGroup.style.transition = 'opacity 1s ease';
          
          // Position the container to match where bubbles ended (top of screen)
          questionContainer.style.cssText = `
            text-align: center;
            max-width: 700px;
            margin: -180px auto 0;
            display: block;
            position: relative;
          `;
          
          questionText.textContent = 'Will you be my valentine?';
          questionText.style.opacity = '0';
          questionText.style.transition = 'opacity 2s ease';
          questionText.style.marginBottom = '40px';
          
          // Fade in the text
          setTimeout(() => {
            questionText.style.opacity = '1';
            
            // Show input group after text is fully visible
            setTimeout(() => {
              inputGroup.style.opacity = '1';
            }, 2000); // Wait for text to fully fade in
          }, 50);
          
          // Remove phrase container after fade completes
          setTimeout(() => {
            blanksContainer.innerHTML = '';
          }, 2000);
        }, 100);
      }, 1300);
    }

    // Submit final answer
    function submitFinalAnswer() {
      const input = document.getElementById('final-answer-input').value;
      const errorMessage = document.getElementById('final-error-message');

      if (validateAnswer(input, 'yes')) {
        errorMessage.classList.remove('show');
        showVictory();
      } else {
        errorMessage.classList.add('show');
        setTimeout(() => {
          errorMessage.classList.remove('show');
        }, 2000);
      }
    }

    // Show victory screen
    function showVictory() {
      showScreen('victory');
      playVictoryAnimation();
    }

    // Play victory animation
    function playVictoryAnimation() {
      const canvas = document.getElementById('fireworks-canvas');
      const ctx = canvas.getContext('2d');
      
      // Set canvas size
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);
      
      // Firework colors - red, pink, purple (bright and vibrant)
      const colors = [
        '#FF1744', // bright red
        '#F50057', // bright pink
        '#D500F9', // bright purple
        '#FF4081', // lighter pink
        '#E040FB', // lighter purple
        '#FF5252'  // lighter red
      ];
      
      // Firework class
      class Firework {
        constructor() {
          this.reset();
        }
        
        reset() {
          this.x = Math.random() * canvas.width;
          this.y = canvas.height;
          this.targetY = Math.random() * canvas.height * 0.4 + canvas.height * 0.1;
          this.speed = Math.random() * 3 + 4;
          this.size = Math.random() * 2 + 1;
          this.color = colors[Math.floor(Math.random() * colors.length)];
          this.exploded = false;
          this.particles = [];
          this.type = Math.floor(Math.random() * 3); // 0: burst, 1: sparkle, 2: expanding circle
        }
        
        update() {
          if (!this.exploded) {
            this.y -= this.speed;
            if (this.y <= this.targetY) {
              this.explode();
            }
          } else {
            this.particles.forEach((particle, index) => {
              particle.update();
              if (particle.opacity <= 0) {
                this.particles.splice(index, 1);
              }
            });
            
            if (this.particles.length === 0) {
              this.reset();
            }
          }
        }
        
        explode() {
          this.exploded = true;
          const particleCount = Math.random() * 30 + 50;
          
          for (let i = 0; i < particleCount; i++) {
            if (this.type === 0) {
              // Classic circular burst
              this.particles.push(new BurstParticle(this.x, this.y, this.color));
            } else if (this.type === 1) {
              // Sparkle particles
              this.particles.push(new SparkleParticle(this.x, this.y, this.color));
            } else {
              // Expanding circle
              this.particles.push(new CircleParticle(this.x, this.y, this.color, i, particleCount));
            }
          }
        }
        
        draw() {
          if (!this.exploded) {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            ctx.fill();
            
            // Trail effect
            ctx.beginPath();
            ctx.arc(this.x, this.y + 10, this.size * 0.5, 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            ctx.globalAlpha = 0.5;
            ctx.fill();
            ctx.globalAlpha = 1;
          } else {
            this.particles.forEach(particle => particle.draw());
          }
        }
      }
      
      // Burst Particle (radiating outward)
      class BurstParticle {
        constructor(x, y, color) {
          this.x = x;
          this.y = y;
          this.color = color;
          const angle = Math.random() * Math.PI * 2;
          const speed = Math.random() * 3 + 2;
          this.vx = Math.cos(angle) * speed;
          this.vy = Math.sin(angle) * speed;
          this.gravity = 0.05;
          this.friction = 0.98;
          this.opacity = 1;
          this.size = Math.random() * 3 + 2;
        }
        
        update() {
          this.vx *= this.friction;
          this.vy *= this.friction;
          this.vy += this.gravity;
          this.x += this.vx;
          this.y += this.vy;
          this.opacity -= 0.015;
        }
        
        draw() {
          ctx.save();
          ctx.globalAlpha = this.opacity;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fillStyle = this.color;
          ctx.fill();
          ctx.restore();
        }
      }
      
      // Sparkle Particle (twinkling stars)
      class SparkleParticle {
        constructor(x, y, color) {
          this.x = x;
          this.y = y;
          this.color = color;
          const angle = Math.random() * Math.PI * 2;
          const speed = Math.random() * 2 + 1;
          this.vx = Math.cos(angle) * speed;
          this.vy = Math.sin(angle) * speed;
          this.gravity = 0.03;
          this.friction = 0.99;
          this.opacity = 1;
          this.size = Math.random() * 2 + 1;
          this.twinkle = Math.random() * Math.PI * 2;
        }
        
        update() {
          this.vx *= this.friction;
          this.vy *= this.friction;
          this.vy += this.gravity;
          this.x += this.vx;
          this.y += this.vy;
          this.opacity -= 0.01;
          this.twinkle += 0.2;
        }
        
        draw() {
          ctx.save();
          ctx.globalAlpha = this.opacity * (Math.sin(this.twinkle) * 0.5 + 0.5);
          ctx.beginPath();
          
          // Draw star shape
          const spikes = 4;
          const outerRadius = this.size * 2;
          const innerRadius = this.size;
          
          for (let i = 0; i < spikes * 2; i++) {
            const radius = i % 2 === 0 ? outerRadius : innerRadius;
            const angle = (i * Math.PI) / spikes;
            const px = this.x + Math.cos(angle) * radius;
            const py = this.y + Math.sin(angle) * radius;
            
            if (i === 0) {
              ctx.moveTo(px, py);
            } else {
              ctx.lineTo(px, py);
            }
          }
          
          ctx.closePath();
          ctx.fillStyle = this.color;
          ctx.fill();
          ctx.restore();
        }
      }
      
      // Circle Particle (expanding ring)
      class CircleParticle {
        constructor(x, y, color, index, total) {
          this.centerX = x;
          this.centerY = y;
          this.color = color;
          this.angle = (index / total) * Math.PI * 2;
          this.radius = 0;
          this.maxRadius = Math.random() * 100 + 80;
          this.speed = Math.random() * 2 + 3;
          this.opacity = 1;
          this.size = Math.random() * 2 + 1;
        }
        
        update() {
          this.radius += this.speed;
          if (this.radius > this.maxRadius * 0.6) {
            this.opacity -= 0.02;
          }
        }
        
        draw() {
          ctx.save();
          ctx.globalAlpha = this.opacity;
          const x = this.centerX + Math.cos(this.angle) * this.radius;
          const y = this.centerY + Math.sin(this.angle) * this.radius;
          ctx.beginPath();
          ctx.arc(x, y, this.size, 0, Math.PI * 2);
          ctx.fillStyle = this.color;
          ctx.fill();
          ctx.restore();
        }
      }
      
      // Create fireworks array
      const fireworks = [];
      const fireworkCount = 8; // Base number of simultaneous fireworks
      
      for (let i = 0; i < fireworkCount; i++) {
        fireworks.push(new Firework());
        // Stagger initial launches
        fireworks[i].y = canvas.height + i * 100;
      }
      
      // Random launch timing
      let lastLaunchTime = 0;
      const launchInterval = 300; // Launch new firework every 300ms on average
      
      // Animation loop
      function animate() {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Random launches
        const now = Date.now();
        if (now - lastLaunchTime > launchInterval && Math.random() < 0.3) {
          const inactiveFw = fireworks.find(fw => fw.y >= canvas.height);
          if (inactiveFw) {
            inactiveFw.reset();
            lastLaunchTime = now;
          }
        }
        
        fireworks.forEach(firework => {
          firework.update();
          firework.draw();
        });
        
        requestAnimationFrame(animate);
      }
      
      animate();
    }

    // Start the game on page load
    initGame();
  </script>
</body>
</html>